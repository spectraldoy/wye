// References:
// - https://lalrpop.github.io/lalrpop/index.html
// - https://github.com/Storyyeller/cubiml-demo/blob/master/src/grammar.lalr

use super::ast;
use ordered_float::OrderedFloat;

grammar;

// Comments
match {
    r"\s" => { },
    r"#[^\n\r]*[\n\r]*" => { }, // Skip `# comments`
    r#"\(\*[^*]*\*+(?:[^\)*][^*]*\*+)*\)"# => { },  // Skip `(* comments *)`
} else {
    _
}

// Macros
SepList<T, Sep>: Vec<T> = {
    "[" Space* <prefix: (<T> Space*)?> <mut v: (Sep Space* <T> Space*)*> Space* "]" => match prefix {
        None => v,
        Some(val) => {
            let mut out = vec![prefix];
            out.append(&mut v);
            out
        }
    }
};
SepListAtLeastOne<T, Sep>: Vec<T> = {
    <prefix: T> <mut v: (Space* Sep Space* <T>)*> => {
        let mut out = vec![prefix];
        out.append(&mut v);
        out
    }
};
SepListAtLeastTwo<T, Sep>: Vec<T> = {
    <mut v: (<T> Space* Sep Space*)+> <suffix: T> => {
        v.push(suffix);
        v
    }
};
SepTuple<T, Sep>: Vec<T> = {
    <mut v: (<T> Space* Sep Space*)+> <suffix: T?> => match suffix {
        None => v,
        Some(val) => {
            v.push(val);
            v
        }
    }
};

// Literals / Identifiers

Identifier: ast::Identifier = <r"_*[a-z]\w*"> => String::from(<>);

TypedIdentifier: (ast::Identifier, ast::TypeExpression) =
    <id: Identifier> ":" <te: TypeExpression> => (id, te);

TypeId: ast::TypeId = <r"_*[A-Z]\w*"> => String::from(<>);

TypeVar: ast::TypeVar = <s: r"'_*[a-z]\w*"> => String::from(s[1..].to_string());

IntegerLiteral: i64 = <r"-?([0-9]|[1-9][0-9]*)"> => <>.parse::<i64>().unwrap();

StringLiteral: String = <s: r#""[^\"]*""#> => s[1..s.len() - 1].into();

FloatLiteral: OrderedFloat<f64> =
    <r"-?([0-9]|[1-9][0-9]*)\.[0-9]+([eE]-?[0-9]+)?"> => 
        OrderedFloat(<>.parse::<f64>().unwrap());

BuiltinOp: ast::Operation = {
    "+" => ast::Operation::Add,
    "-" => ast::Operation::Subtract,
    "*" => ast::Operation::Multiply,
    "/" => ast::Operation::Divide,
    "//" => ast::Operation::FloorDiv,
    "<" => ast::Operation::Lt,
    ">" => ast::Operation::Gt,
    "<=" => ast::Operation::Leq,
    ">=" => ast::Operation::Geq,
    "==" => ast::Operation::Eq,
    "!=" => ast::Operation::Neq,
    "::" => ast::Operation::Cons,
}

TypeVariantType: (ast::TypeId, Option<ast::TypeExpression>) = {
    <tid: TypeId> => (tid, None),
    <tid: TypeId> Space+ "with" Space+ <field_t: TypeExpression> => (tid, Some(field_t))
}

// Expressions

pub Expression: ast::Expression = {
    #[precedence(level="0")]
    <i: IntegerLiteral> => ast::Expression::IntegerLiteral(i),
    <f: FloatLiteral> => ast::Expression::FloatLiteral(f),
    <s: StringLiteral> => ast::Expression::StringLiteral(s),
    "[" <v: SepListAtLeastOne<Expression, ",">> "]" => ast::Expression::List(v),
    "[" "]" => ast::Expression::List(vec![]),
    "(" <t: SepTuple<Expression, ",">> ")" => ast::Expression::Tuple(t),
    <id: Identifier> => ast::Expression::Variable(id),
    <tid: TypeId> => ast::Expression::TypeVariant(tid, None),
    <tid: TypeId> "with" <field: Expression> => ast::Expression::TypeVariant(tid, Some(Box::new(field))),
    "(" <e: Expression> ")" => e,
    // Functions are left-associative
    #[precedence(level="1")]
    #[assoc(side="left")]
    <func: Expression> Space <arg: Expression> => ast::Expression::FuncApplication(
        Box::new(func), Box::new(arg)
    ),
    // TODO: pattern matching and functions
    // TODO: finish statement parsing, then impl let block
};

TypeExprHelper: ast::TypeExpression = {
    "int" => ast::TypeExpression::IntType,
    "float" => ast::TypeExpression::FloatType,
    "string" => ast::TypeExpression::StringType,
    "[" <te: TypeExpression> "]" => ast::TypeExpression::ListType(Box::new(te)),
    "(" <tes: SepTuple<TypeExpression, ",">> ")" => ast::TypeExpression::TupleType(tes),
    <tvar: TypeVar> => ast::TypeExpression::TypeVariable(tvar),
    "(" <ftype: SepListAtLeastTwo<TypeExpression>> "->" ")" => ast::TypeExpression::FunctionType(ftype),
    "(" <te: TypeExpression> ")" => te
};

// TODO: tokens

pub TypeExpression: ast::TypeExpression = {
    <c: TypeExprHelper> => c,
    <t: TypeId> <targs: DeclTypeArgs*> => ast::TypeExpression::DeclaredType(t, targs),
};


// Statements

Statement: ast::Statement = {
    "let" <ids: Identifier+> "=" <e: Expression> ";" => {
        ast::Statement::UntypedLet(String::from(&ids[0]), ids[1..].to_vec(), Box::new(e))
    },
    "let" <typed_ids: SepListAtLeastOne<TypedIdentifier, "->">> "=" <e: Expression >";" => {
        ast::Statement::TypedLet(typed_ids, Box::new(e))
    },
    //"type" <tid: TypeId> <tvars: TypeVar*> "=" <variants: SepList<TypeVariantType, "|">> ";" => {
    //    ast::Statement::TypeDeclaration(tid, tvars, variants)
    //}
}

pub WyeProgram = <Statement+>;

