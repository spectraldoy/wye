use super::ast;
use super::span::{Spanned, make_spanned};
use ordered_float::OrderedFloat;
use lalrpop_util::ParseError;

grammar;

// Comments
match {
    r"\s+" => { }, // Ignore whitespace
    r"#[^\n\r]*[\n\r]*" => { }, // Skip `# comments`
    r#"\(\*[^*]*\*+(?:[^\)*][^*]*\*+)*\)"# => { },  // Skip `(* comments *)`
} else {
    _
}

// TODO: null token and lambda

// Macros
Sp<Rule>: Spanned<Rule> = <l: @L> <rule: Rule> <r: @R> =>
    make_spanned(l, r, rule);

// Tokens
Identifier: ast::Identifier<'input> = r"[a-zA-Z_]\w*";

TypedIdentifier: (ast::Identifier<'input>, ast::TypeExpression<'input>) =
    <id: Identifier> ":" <te: TypeExpression> => (id, te);

TypeVar: ast::Identifier<'input> = <s: r"'_*[a-z]\w*"> => &s[1..];

IntegerLiteral: i64 = <r"-?([0-9]|[1-9][0-9]*)"> => <>.parse::<i64>().unwrap();

StringLiteral: String = <s: r#""[^\"]*""#> => s[1..s.len() - 1].to_string();

FloatLiteral: OrderedFloat<f64> =
    <r"-?([0-9]|[1-9][0-9]*)\.[0-9]+([eE]-?[0-9]+)?"> => 
        OrderedFloat(<>.parse::<f64>().unwrap());

BuiltinOp: ast::Operation = {
    "+" => ast::Operation::Add,
    "-" => ast::Operation::Subtract,
    "*" => ast::Operation::Multiply,
    "/" => ast::Operation::Divide,
    "//" => ast::Operation::FloorDiv,
    "<" => ast::Operation::Lt,
    ">" => ast::Operation::Gt,
    "<=" => ast::Operation::Leq,
    ">=" => ast::Operation::Geq,
    "==" => ast::Operation::Eq,
    "!=" => ast::Operation::Neq,
    "::" => ast::Operation::Cons,
}

TypeVariantType: (ast::Identifier<'input>, Option<ast::TypeExpression<'input>>) = {
    <tid: Identifier> => (tid, None),
    <tid: Sp<Identifier>> <with: Sp<"with">> <field_t: Sp<TypeExpression>> =>? {
        if tid.end == with.start {
            Err(ParseError::User {
                error: "Type of variant with argument requires space between TypeId and with token"
            })
        } else if with.end == field_t.start {
            Err(ParseError::User {
                error: "Type of variant with argument requires space between with token and field type"
            })
        } else {
            Ok((tid.value, Some(field_t.value)))
        }
    }
}

// Expressions

// pub Expression: ast::Expression = {
//     #[precedence(level="0")]
//     <i: IntegerLiteral> => ast::Expression::IntegerLiteral(i),
//     <f: FloatLiteral> => ast::Expression::FloatLiteral(f),
//     <s: StringLiteral> => ast::Expression::StringLiteral(s),
//     "[" <v: SepListAtLeastOne<Expression, ",">> "]" => ast::Expression::List(v),
//     "[" "]" => ast::Expression::List(vec![]),
//     "(" <t: SepTuple<Expression, ",">> ")" => ast::Expression::Tuple(t),
//     <id: Identifier> => ast::Expression::Variable(id),
//     <tid: TypeId> => ast::Expression::TypeVariant(tid, None),
//     <tid: TypeId> "with" <field: Expression> => ast::Expression::TypeVariant(tid, Some(Box::new(field))),
//     "(" <e: Expression> ")" => e,
//     // Functions are left-associative
//     #[precedence(level="1")]
//     #[assoc(side="left")]
//     <func: Expression> Space <arg: Expression> => ast::Expression::FuncApplication(
//         Box::new(func), Box::new(arg)
//     ),
//     // TODO: pattern matching and functions
//     // TODO: finish statement parsing, then impl let block
// };

TypeExprHelper: ast::TypeExpression<'input> = {
    "int" => ast::TypeExpression::IntType,
    "float" => ast::TypeExpression::FloatType,
    "string" => ast::TypeExpression::StringType,
    // "[" <te: TypeExpression> "]" => ast::TypeExpression::ListType(Box::new(te)),
    // "(" <tes: SepTuple<TypeExpression, ",">> ")" => ast::TypeExpression::TupleType(tes),
    // <tvar: TypeVar> => ast::TypeExpression::TypeVariable(tvar),
    // "(" <ftype: SepListAtLeastTwo<TypeExpression>> "->" ")" => ast::TypeExpression::FunctionType(ftype),
    // "(" <te: TypeExpression> ")" => te
};

pub TypeExpression: ast::TypeExpression<'input> = {
    <c: TypeExprHelper> => c,
    // <t: Identifier> <targs: DeclTypeArgs*> => ast::TypeExpression::DeclaredType(t, targs),
};