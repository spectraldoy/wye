use super::ast;
use super::span::Spanned;
use super::util;
use ordered_float::OrderedFloat;
use lalrpop_util::ParseError;

grammar;

// Comments
match {
    r"\s+" => { }, // Ignore whitespace
    r"#[^\n\r]*[\n\r]*" => { }, // Skip `# comments`
    r#"\(\*[^*]*\*+(?:[^\)*][^*]*\*+)*\)"# => { },  // Skip `(* comments *)`
} else {
    _
}

// TODO: custom error type and better error messages

// Macros
Sp<Rule>: Spanned<Rule> = <l: @L> <rule: Rule> <r: @R> => Spanned::new(l, r, rule);

SepListAtLeastOne<T, Sep>: Vec<T> = { // (1)
    <mut v: (<T> Sep)*> <suffix: T> => {
        v.push(suffix);
        v
    }
}

SepListAtLeastTwo<T, Sep>: Vec<T> = { // (1)
    <mut v: (<T> Sep)+> <suffix: T> => {
        v.push(suffix);
        v
    }
}

SepTuple<T, Sep>: Vec<T> = {
    <mut v: (<T> Sep)+> <suffix: T?> => match suffix {
        None => v,
        Some(val) => {
            v.push(val);
            v
        }
    }
}

SepTupleAtLeastTwo<T, Sep>: Vec<T> = {
    <prefix: T> <mut v: (Sep <T>)+> Sep? => {
        let mut out = vec![prefix];
        out.append(&mut v);
        out
    }
}

// Tokens
Identifier: ast::Identifier<'input> = <r"[a-zA-Z_]\w*">;

TypedIdentifier: (ast::Identifier<'input>, ast::TypeExpression<'input>) =
    <id: Identifier> ":" <te: TypeExpression> => (id, te);

TypeVar: ast::Identifier<'input> = <s: r"'[a-zA-Z_]\w*"> => &s[1..];

IntegerLiteral: i64 = <r"-?([0-9]|[1-9][0-9]*)"> => <>.parse::<i64>().unwrap();

StringLiteral: String = <s: r#""[^\"]*""#> => s[1..s.len() - 1].to_string();

FloatLiteral: OrderedFloat<f64> =
    <r"-?([0-9]|[1-9][0-9]*)\.[0-9]+([eE]-?[0-9]+)?"> => 
        OrderedFloat(<>.parse::<f64>().unwrap());

BuiltinOp: ast::Operation = {
    "+" => ast::Operation::Add,
    "-" => ast::Operation::Subtract,
    "*" => ast::Operation::Multiply,
    "/" => ast::Operation::Divide,
    "//" => ast::Operation::FloorDiv,
    "<" => ast::Operation::Lt,
    ">" => ast::Operation::Gt,
    "<=" => ast::Operation::Leq,
    ">=" => ast::Operation::Geq,
    "==" => ast::Operation::Eq,
    "!=" => ast::Operation::Neq,
    "::" => ast::Operation::Cons,
}

// Expressions

AtomicExpr: ast::Expression<'input> = {
    <i: IntegerLiteral> => ast::Expression::IntegerLiteral(i),
    <f: FloatLiteral> => ast::Expression::FloatLiteral(f),
    <s: StringLiteral> => ast::Expression::StringLiteral(s),
    "[" "]" => ast::Expression::List(vec![]),
    "[" <v: SepListAtLeastOne<Expression, ",">> "]" => ast::Expression::List(v),
    <id: Identifier> => ast::Expression::Identifier(id),
    "(" <bop: BuiltinOp> ")" => ast::Expression::BuiltinOp(bop),
    "print" => ast::Expression::Print,
    "error" => ast::Expression::Error,
    "(" <t: SepTuple<Expression, ",">> ")" => ast::Expression::Tuple(t),
    "(" <e: Expression> ")" => e,
}

pub Expression: ast::Expression<'input> = {
    AtomicExpr,
    <tid: Sp<Identifier>> <with: Sp<"with">> <field: Sp<AtomicExpr>> =>? {
        if tid.end == with.start {
            Err(ParseError::User {
                error: "Variant with argument requires space between TypeId and `with` token"
            })
        } else if with.end == field.start {
            Err(ParseError::User {
                error: "Variant with argument requires space between `with` token and field expression"
            })
        } else {
            Ok(ast::Expression::TypeVariant(tid.value, Box::new(field.value)))
        }
    },
    <func: Sp<AtomicExpr>> <args: Sp<AtomicExpr>+> =>? match util::collect_function::<ast::Expression>(
        func,
        args,
        |e1, e2| ast::Expression::FuncApplication(Box::new(e1), Box::new(e2))
    ) {
        Ok(v) => Ok(v),
        Err(e) => Err(ParseError::User { error: e })
    },
    // BuiltinOp
    <op1: AtomicExpr> <bop: BuiltinOp> <op2: AtomicExpr> => ast::Expression::FuncApplication(
        Box::new(ast::Expression::FuncApplication(
            Box::new(ast::Expression::BuiltinOp(bop)),
            Box::new(op1)
        )),
        Box::new(op2)
    ),
    <match_: Sp<"match">> <matchand: Sp<Expression>> "{" <arm: (<Pattern> "=>" <Expression> ","?)> "}" =>? {
        if match_.end == matchand.start {
            Err(ParseError::User {
                error: "Space required between `match` keyword and matchand"
            })
        } else {
            Ok(ast::Expression::MatchConstruct(
                Box::new(matchand.value), vec![arm]
            ))
        }
    },
    <match_: Sp<"match">> <matchand: Sp<Expression>> "{" <arms: SepTupleAtLeastTwo<(<Pattern> "=>" <Expression>), ",">> "}" =>? {
        if match_.end == matchand.start {
            Err(ParseError::User {
                error: "Space required between `match` keyword and matchand"
            })
        } else {
            Ok(ast::Expression::MatchConstruct(
                Box::new(matchand.value), arms
            ))
        }
    },
    r"\\" <ids: Identifier+> "->" <body: Expression> => ast::Expression::Lambda(ids, Box::new(body)),
    "{" <stmts: Statement*> <e: Expression> "}" => {
        ast::Expression::Block(stmts, Box::new(e))
    }
}

AtomicPattern: ast::Pattern<'input> = {
    "_" => ast::Pattern::Wildcard,
    <i: IntegerLiteral> => ast::Pattern::IntegerLiteral(i),
    <f: FloatLiteral> => ast::Pattern::FloatLiteral(f),
    <s: StringLiteral> => ast::Pattern::StringLiteral(s),
    <id: Identifier> => ast::Pattern::Identifier(id),
    <tid: Sp<Identifier>> <with: Sp<"with">> <field: Sp<CompoundPattern>> =>? {
        if tid.end == with.start {
            Err(ParseError::User {
                error: "Variant with argument requires space between TypeId and `with` token"
            })
        } else if with.end == field.start {
            Err(ParseError::User {
                error: "Variant with argument requires space between `with` token and field identifier"
            })
        } else {
            Ok(ast::Pattern::TypeVariant(tid.value, Box::new(field.value)))
        }
    },
    "[" "]" => ast::Pattern::EmptyList,
    "(" <AtomicPattern> ")" => <>,
}

ScopablePattern: ast::Pattern<'input> = {
    AtomicPattern,
    <head: Identifier> "::" <tail: Identifier> => ast::Pattern::ListConstruction(head, tail),
}

CompoundPattern: ast::Pattern<'input> = {
    ScopablePattern,
    "[" <pats: SepListAtLeastOne<ScopablePattern, ",">> "]" => ast::Pattern::List(pats),
    "(" <pats: SepTuple<ScopablePattern, ",">> ")" => ast::Pattern::Tuple(pats),
}

UnguardedPattern: ast::Pattern<'input> = {
    CompoundPattern,
    <pats: SepListAtLeastTwo<AtomicPattern, "|">> => ast::Pattern::Union(pats),
    "~" <pat: CompoundPattern> => ast::Pattern::Complement(Box::new(pat)),
}

pub Pattern: ast::Pattern<'input> = {
    UnguardedPattern,
    <pat: Sp<UnguardedPattern>> <if_: Sp<"if">> <guard: Sp<Expression>> =>? {
        if pat.end == if_.start {
            Err(ParseError::User {
                error: "Space required between pattern to guard and `if` token"
            })
        } else if if_.end == guard.start {
            Err(ParseError::User {
                error: "Space required between `if` token and guard expression"
            })
        } else {
            Ok(ast::Pattern::Guarded(Box::new(pat.value), guard.value))
        }
    },
}

AtomicTypeExpr: ast::TypeExpression<'input> = {
    "int" => ast::TypeExpression::IntType,
    "float" => ast::TypeExpression::FloatType,
    "string" => ast::TypeExpression::StringType,
    "[" <te: TypeExpression> "]" => ast::TypeExpression::ListType(Box::new(te)),
    "(" <te: TypeExpression> ")" => te,
    "(" <tes: SepTuple<TypeExpression, ",">> ")" => ast::TypeExpression::TupleType(tes),
    <tvar: TypeVar> => ast::TypeExpression::TypeVariable(tvar),
}

NonFuncTypeExpr: ast::TypeExpression<'input> = {
    AtomicTypeExpr,
    // <Declared TypeId> <TypeArgs>
    <t: Sp<Identifier>> <targs: Sp<AtomicTypeExpr>*> =>? {
        let mut texpr_spans = vec![(t.start, t.end)];
        let (targ_vals, mut targ_spans): (Vec<_>, Vec<_>) = targs.iter().map(|el| {
            (el.value.clone(), (el.start, el.end))
        }).unzip();
        texpr_spans.append(&mut targ_spans);
        if util::spans_overlap(&texpr_spans) {
            Err(ParseError::User {
                error: "Space required between tokens here, cannot identify type arguments"
            })
        } else {
            Ok(ast::TypeExpression::DeclaredType(t.value, targ_vals))
        }
    },
}

pub TypeExpression: ast::TypeExpression<'input> = {
    NonFuncTypeExpr,
    <ftype: SepListAtLeastTwo<Sp<NonFuncTypeExpr>, "->" >> =>? match util::collect_function::<ast::TypeExpression>(
        ftype[0].clone(),
        ftype[1..].to_vec(),
        |t1, t2| ast::TypeExpression::FunctionType(Box::new(t1), Box::new(t2))
    ) {
        Ok(v) => Ok(v),
        Err(e) => Err(ParseError::User { error: e })
    }
}

// Program

TypeVariantDeclType: (ast::Identifier<'input>, Option<ast::TypeExpression<'input>>) = {
    <tid: Identifier> => (tid, None),
    <tid: Sp<Identifier>> <with: Sp<"with">> <field_t: Sp<TypeExpression>> =>? {
        if tid.end == with.start {
            Err(ParseError::User {
                error: "Type of variant with argument requires space between TypeId and `with` token"
            })
        } else if with.end == field_t.start {
            Err(ParseError::User {
                error: "Type of variant with argument requires space between `with` token and field type"
            })
        } else {
            Ok((tid.value, Some(field_t.value)))
        }
    }
}

pub Statement: ast::Statement<'input> = {
    <let_: Sp<"let">> <ids: Sp<Identifier>+> "=" <e: Expression> ";" =>? {
        if let_.end == ids[0].start {
            Err(ParseError::User {
                error: "Space required between `let` token and first identifier in let statement"
            })
        } else if util::spans_overlap(&ids.iter().map(|x| (x.start, x.end)).collect::<Vec<_>>()) {
            Err(ParseError::User {
                error: "Identifiers in untyped let require space between them"
            })
        } else {
            Ok(ast::Statement::UntypedLet(
                ids.iter().map(|x| x.value).collect::<Vec<_>>(), e
            ))
        }
    },
    <let_: Sp<"let">> <typed_id: Sp<TypedIdentifier>> "=" <e: Expression> ";" =>? {
        if let_.end == typed_id.start {
            Err(ParseError::User {
                error: "Space required between `let` token and first identifier in let statement"
            })
        } else {
            Ok(ast::Statement::TypedLet(typed_id.value.0, typed_id.value.1, vec![], e))
        }
    },
    <let_: Sp<"let">> <id: Sp<Identifier>> <typed_ids: ("(" <TypedIdentifier> ")" "->")+> <te: TypeExpression> "=" <e: Expression> ";" =>? {
        if let_.end == id.start {
            Err(ParseError::User {
                error: "Space required between `let` token and first identifier"
            })
        } else {
            Ok(ast::Statement::TypedLet(id.value, te, typed_ids, e)   )
        }
    },
    <type_: Sp<"type">> <tid: Sp<Identifier>> <tvars: Sp<TypeVar>*> "=" <variants: SepListAtLeastOne<TypeVariantDeclType, "|">> ";" =>? {
        if type_.end == tid.start {
            Err(ParseError::User {
                error: "Space required between `type` token and declared type name"
            })
        } else if tvars.len() != 0 && tid.end == tvars[0].start {
            Err(ParseError::User {
                error: "Space required between declared type name and type arguments"
            })
        } else if util::spans_overlap(&tvars.iter().map(|tv| (tv.start, tv.end)).collect::<Vec<_>>()) {
            Err(ParseError::User {
                error: "Type variables in type declaration require space between them"
            })
        } else {
            Ok(ast::Statement::TypeDeclaration(
                tid.value,
                tvars.iter().map(|tv| tv.value).collect::<Vec<_>>(),
                variants
            ))
        }
    }
}

pub Program: Vec<ast::Statement<'input>> = <stmts: Sp<Statement>+> =>? {
    if util::spans_overlap(&stmts.iter().map(|s| (s.start, s.end)).collect::<Vec<_>>()) {
        Err(ParseError::User {
            error: "Space required between adjacent statements"
        })
    } else {
        Ok(stmts.iter().map(|s| s.value.clone()).collect::<Vec<_>>())
    }
};
