// References:
// - https://lalrpop.github.io/lalrpop/index.html
// - https://github.com/Storyyeller/cubiml-demo/blob/master/src/grammar.lalr

use super::ast;
use ordered_float::OrderedFloat;

grammar;

// Comments
match {
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"#[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r#"\(\*[^*]*\*+(?:[^\)*][^*]*\*+)*\)"# => { },  // Skip `(* comments *)`
} else {
    _
}

// Macros
SepList<T, Sep>: Vec<T> = {
    <prefix: (<T> Sep)*> <suffix: T?> => match suffix {
        None => prefix,
        Some(val) => {
            let mut out = prefix;
            out.push(val);
            out
        }
    }
};
SepTuple<T, Sep>: Vec<T> = {
    <prefix: (<T> Sep)+> <suffix: T?> => match suffix {
        None => prefix,
        Some(val) => {
            let mut out = prefix;
            out.push(val);
            out
        }
    }
};
SuffixedList<T, Suffix>: Vec<T> = (<T> Suffix)+;

// Literals / Identifiers

Identifier: ast::Identifier = <r"_*[a-z]\w*"> => String::from(<>);
TypeId: ast::TypeId = <r"_*[A-Z]\w*"> => String::from(<>);
IntegerLiteral: i64 = <r"-?([0-9]|[1-9][0-9]*)"> => <>.parse::<i64>().unwrap();
FloatLiteral: OrderedFloat<f64> =
    <r"-?([0-9]|[1-9][0-9]*)\.[0-9]+([eE]-?[0-9]+)?"> => 
        OrderedFloat(<>.parse::<f64>().unwrap());

BuiltinOp: ast::Operation = {
    "+" => ast::Operation::Add,
    "-" => ast::Operation::Subtract,
    "*" => ast::Operation::Multiply,
    "/" => ast::Operation::Divide,
    "//" => ast::Operation::FloorDiv,
    "<" => ast::Operation::Lt,
    ">" => ast::Operation::Gt,
    "<=" => ast::Operation::Leq,
    ">=" => ast::Operation::Geq,
    "==" => ast::Operation::Eq,
    "!=" => ast::Operation::Neq,
    "::" => ast::Operation::Cons,
}

// Expressions

pub Expression: ast::Expression = {
    <i: IntegerLiteral> => ast::Expression::IntegerLiteral(i),
    <f: FloatLiteral> => ast::Expression::FloatLiteral(f),
    "[" <v: SepList<Expression, ",">> "]" => ast::Expression::List(v),
    "(" <t: SepTuple<Expression, ",">> ")" => ast::Expression::Tuple(t),
    <id: Identifier> => ast::Expression::Variable(id),
    <tid: TypeId> => ast::Expression::TypeVariant(tid, None),
};

// Statements

LetStatement: ast::LetStatement = "let" <ids: Identifier+> "=" <e: Expression> ";" => {
    ast::LetStatement::UntypedLet(String::from(&ids[0]), ids[1..].to_vec(), Box::new(e))
};

pub WyeProgram = <LetStatement+>;

