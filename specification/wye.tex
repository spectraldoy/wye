% --- Preamble ---
\documentclass[a4paper, 12pt]{article}

% --- Packages ---
\usepackage{microtype}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage[english]{babel}
\usepackage[titletoc, title]{appendix}
\usepackage[bottom]{footmisc}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{inconsolata}
\usepackage{minted}

\usepackage{setspace}
\usepackage[a4paper, margin=1.15in]{geometry}

\usepackage[square, numbers, comma]{natbib}

\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=blue,
    citecolor=black
}
\urlstyle{same}

% set up Wye lstlistings
\definecolor{darkgreen}{rgb}{0.125, 0.73828125, 0.421875}

\lstdefinelanguage{wye}{
  keywords={let, type, where, with, if, then, else, match, print, error},
  keywordstyle=\color{darkgreen}\bfseries,
  keywords=[2]{int, string, float},
  keywordstyle=[2]\color{blue},
  comment=[l]{\#},
  commentstyle=\color{gray},
  identifierstyle=\color{black},
  stringstyle=\color{red},
  morestring=[b]"
}

\lstset{
   language=wye,
   extendedchars=true,
   basicstyle=\ttfamily\footnotesize,
   showstringspaces=false,
   showspaces=false,
   tabsize=2,
   breaklines=true,
   showtabs=false
}

% newcommands
\newcommand{\bits}{\{0, 1\}}
\newcommand{\sepbar}{\: | \:}	% separated bar
\newcommand{\substo}{\quad\rightarrow\quad}
\newcommand{\uscore}{\underline{\hspace{0.3cm}}}
\newcommand{\version}{1.0.0}
\newcommand{\dedrule}[2]{\begin{align*}\frac{$1}{$2}\end{align*}}
\newcommand{\free}{\text{free}}

% --- Document ---
\begin{document}

% --- Title ---
\title{
\textsc{Wye: a Functional Language} \\
\vspace{2ex}
\large{\textsc{Version \version}}\\
\vspace{2ex}}

\author{\normalsize\textsc{Aditya Gomatam} \\ 
\normalsize{\today\vspace{2ex}}}
\date{}
\maketitle

\setstretch{1.15}

% --- Abstract --- 
\begin{abstract}
To learn more about functional languages and compilers, I decided to build a functional language. This language is intended not only to have a minimal set of features so that it be relatively easy to implement, but also to be useful. As functional programming is based upon the lambda calculus, I have decided to name the language Wye, as $\mathsf{y}$ is $\lambda$ upside-down.

This document will compile the specification of Wye: its syntax, semantics, type system, intermediate representation, register allocation, and finally its translation into an assembly language of choice.
\end{abstract}

% --- Body ---
\section{Introduction}
Wye is a statically-typed functional language based on the lambda calculus. It utilizes a Hindley-Milner type system, which enables both parametric polymorphism and type inference in Wye. For clarity of your code, and to aid the compiler, however, you may annotate the type of Wye variables. Wye also allows the declaration of custom types.

\subsection{Type Classes}
The original ideas for Wye included the ability to create Haskell-like Type Classes, between one could establish subtype relations, and moreover, by which type variables could be bound (for example, one could annotate that a function argument generalize over all \texttt{'Ordered} types, instead of all types). Due to the added complexity of implementing such a system, Type Classes are deferred to a later version of Wye.

\subsection{List Comprehension}
List comprehension should not be too hard to implement compared to the rest of this project, but it will require some additions to the grammar, and so in keeping with the ideal of minimal set of features, are also deferred to a future version.

\subsection{User Input}
In Wye version \version{}, users may only output to the screen. Taking user input is slightly more complicated and is thus deferred to a future version of Wye.

\subsection{Type Aliases}
Similar to TypeScript, it would be nice if the user could do something like the following to create an abbreviation for a type:
\begin{lstlisting}{wye}
# just a tuple-type of length 2
type Pair 'a 'b = ('a, 'b);
\end{lstlisting}

\section{Syntax}
A Wye program is stored in a \texttt{.y} file and follows the below grammar. A Wye program is, in the most abstract view, simply a sequence of Wye statements.

Witten below in Backus-Naur form is roughly the Wye grammar. The start symbol is $Program$. Nonterminals start with a capital letter. Terminals are written in \texttt{this font}. $pat*$ denotes the Kleene star: zero or more repetitions of the pattern $pat$. $pat+$ is a shorthand for $pat\: pat*$. $pat?$ denotes that $pat$ may or may not occur. $( pat_1\:...\: pat_n )$ groups $pat_1, ..., pat_n$ into a new pattern. $pat1 | pat2$ means that exactly one of $pat1$ or $pat2$ may occur. Beware that \texttt{|} and $|$ are different -- the first is a Wye token. $\langle$These brackets$\rangle$ are used to annotate certain grammar rules.

\subsection{Grammar}
\begin{align*}
Program \substo& Statement*\\
Statement \substo& LetStatement \sepbar TypeDeclaration\\
LetStatement \substo& \texttt{let}\: Id \: (\texttt{:}\: Type\sepbar Id* \sepbar ((Id\: \texttt{:}\:Type\:\texttt{->})*\:Type))?:\texttt{=}\: Expr\:\texttt{;}\\
TypeDeclaration \substo& \texttt{type}\: TypeId\: (\texttt{'}\: Id)*\: \texttt{=} \: (TypeId \: (\texttt{with}\: Type)?)\\
&(\texttt{|}\:TypeId \: (\texttt{with}\: Type)?)*\:\texttt{;}\\
Expr\substo& IntLiteral \sepbar FloatLiteral \sepbar StringLiteral \sepbar List \sepbar Tuple\\
& \sepbar Id \sepbar BuiltinOp\:\langle\text{variable/func within current scope}\rangle\\
& \sepbar TypeId\: (\texttt{with}\: Expr)?\: \langle\text{Type variant}\rangle\\
& \sepbar Expr\:Expr\:\langle\text{function application}\rangle\\
& \sepbar Expr \: BuiltinOp \: Expr\:\langle\text{reserved binary operator}\rangle \\
& \sepbar \texttt{match}\: Expr \: \texttt{\{} \: (Pat \: \texttt{=>}\: Expr\: \texttt{;})*\: Pat\texttt{ => } Expr \: (\texttt{;}?) \: \texttt{\}} \\
& \sepbar \texttt{if}\: Expr \: \texttt{then} \: Expr \: \texttt{else} \: Expr \\
& \sepbar \texttt{(}\: Expr \:\texttt{)}\\
& \sepbar \texttt{\{}\: Statement*\: Expr\texttt{\}} \:\langle \text{let .. in block}\rangle\\
& \sepbar \texttt{print} \: Expr \\
& \sepbar \texttt{error} \: Expr \\
Type \substo& \texttt{int} \sepbar \texttt{float} \sepbar \texttt{string}\\
& \sepbar TypeId\: (Type)*\\
& \sepbar \texttt{[}\:Type\:\texttt{]}\\
& \sepbar \texttt{(} \: (Type\: \texttt{,} )+\: Type\: \texttt{)}\\
& \sepbar \texttt{'}\:Id \: \langle\text{type variable}\rangle\\
& \sepbar Type \: \texttt{-> }Type\:\langle\text{function type}\rangle\\
List \substo& \texttt{[}\: (Expr \: \texttt{,})*\: Expr\: \texttt{]} \sepbar \texttt{[]}\\
Tuple \substo& \texttt{(}\: (Expr \: \texttt{,})+\: Expr\: \texttt{)}\\
BuiltinOp \substo& \texttt{+}\sepbar\texttt{-}\sepbar\texttt{*}\sepbar\texttt{/}\sepbar\texttt{//}\sepbar\texttt{::}\sepbar\texttt{<}\sepbar\texttt{<=}\sepbar\texttt{>}\sepbar\texttt{>=}\sepbar\texttt{==}\sepbar\texttt{!=}\\
Pat \substo& Expr \sepbar \uscore\\
& \sepbar Id\:\texttt{::}\: Id\:\langle\text{head : tail list destructuring}\rangle\\
& \sepbar TypeId \: (\texttt{with}\: Id)?\\
& \sepbar \texttt{[} \: ( Pat\:\texttt{,})*\: Pat \: \texttt{]} \sepbar  \texttt{[]}\\
& \sepbar \texttt{(} \: ( Pat\:\texttt{,})+\: Pat\: \texttt{)}\\
& \sepbar \sim\:Pat \:\langle\text{pattern negation}\rangle
\end{align*}
\pagebreak

The exact substitution rules for the $Literal$ patterns listed on the first line of the $Expr$ substitution rules is omitted to avoid boring the reader. If you are reading this, you know what a float is. Similarly, the rules for $Uppercase$ and other character sets are omitted. Note that Wye uses ASCII as its character set for identifiers and type names, though strings may contain Unicode characters.

$Id$s and $TypeId$s should not be any of the builtin keywords such as \texttt{int}, \texttt{float}, \texttt{string}, \texttt{print}, \texttt{match}, \texttt{with}, \texttt{then}, and so on. $Id$s begin with a lowercase letter after as many underscores as you want, and $TypeId$s begin with an uppercase letter, also after as many underscores as you want. Thus, $Id$s and $TypeId$s cannot conflict with each other within their scope, and the parser does not find any ambiguity here.

Notice that \texttt{bool} is not a builtin type. This is because the $TypeDeclaration$ system of Wye is used to define it in the Wye prelude. Following that, \texttt{if then else} is just syntactic sugar for \texttt{match} on the enum variants of \texttt{bool}.

One-line Wye comments begin with \texttt{\#} and mark all following text until the next carriage return or newline as whitespace. Multiline Wye comments begin with \texttt{(*} and end with \texttt{*)}.

In Wye, the application of functions is always written in postfix notation, except for certain reserved binary operations (such as \texttt{+}) that may be written in infix notation. These binary operations are, under the hood, translated into postfix notation.

\section{Semantics}

\subsection{Statements}
Currently, there are two types of statements in Wye | let statements and type declarations. The following are valid examples of Wye statements:

\subsubsection{Let Statements}
Wye \texttt{let} statements declare constants (referred to throughout this document as variables for consistency with common notions of \texttt{let}) at the top-level, or within blocks. In Wye, functions are first-class -- that is, they occupy the same status as ``regular" types. They can be declared as variables, passed as function arguments, and so on.

Variables declared using \texttt{let} statements are visible throughout their entire scope, both backwards and forwards. Blocks create nested scopes. The variables declared in such nested scopes are not visible in outer scopes. Function arguments shadow over the outer scope. Here are some examples:
\begin{lstlisting}{wye}
# variable (actually a constant)
let x = 4;
# type-annotated variable
let y: int = 4;
# function
let plus_4 x = (+ x 4);
# type-annotated functions
let plus_4 x: int -> int = (+ x 4);
let id: x: 'a -> 'a = x;
let into_tup x: int -> y: float -> z: string -> (int, float, string)
	= ((plus_4 x), y, (id z));
# blocks
let y = {
	5
};
let doublesum lst: [int] -> int = {
	let sum lst: [int] -> int = match lst {
		[] => 0;
		x :: xs => (+ x (sum xs));
	};
	(* 2 (sum lst)) # no semicolon
}; # semicolon
\end{lstlisting}
It would be slightly uncomfortable to express this within the grammar, but Wye reserves a let statement of the following form at the top-level to be its Main statement -- that is, the expression on the right hand side is run when the \texttt{.y} file is executed from the command line:
\begin{lstlisting}{wye}
let Main = print (plus_4 6);
\end{lstlisting}
Apart from \texttt{Main}, every function in Wye is pure, i.e., it will not affect the scope outside of the function. There are no global mutable variables, and the only function that is allowed to call other functions that take input or output to the terminal is \texttt{Main}.

\subsubsection{Type Declarations}
Type declarations in Wye are akin to enums in Rust. Variants of the type are separated by \texttt{|} and one may choose to give any variant an optional field. Unlike Rust, wherein enums can have multiple fields, Wye allows only one field. However, one can declare this field to have a tuple type, which will allow the variant to behave as if it holds multiple fields. Moreover, user-defined types can be \textit{polymorphic} -- that is, they may have a type argument. See the following examples:
\begin{lstlisting}{wye}
type bool = false | true;
type Option 'a = None | Some with 'a;
type binary_tree 'a = Leaf
	| Node with ('a, binary_tree 'a, binary_tree 'a);
\end{lstlisting}
One can think of polymorphic user-defined types as ``type functions" that take in a type parameter and output an instance of a type. In the above example \texttt{Some with 4} would take in the type \texttt{int} of the expression \texttt{4} and output an instance of \texttt{Option int}.

\subsection{Expressions}
The right hand side of every let statement in Wye must be an expression. Wye version \version{} supports only a few expressions. Most of them exist in other languages and are fairly self-explanatory. This section will go over the less familiar ones.

\subsubsection{Function Application}
As a language that implements the lambda calculus, Wye supports function application, which expressed as the following grammar rule:
\begin{align*}
Expr\substo& Expr\: Expr
\end{align*}
For example:
\begin{lstlisting}{wye}
let f x: int -> y: int -> int = (+ x y);
let plus_4 y: int -> int = f 4;
\end{lstlisting}
Functions in Wye are \textit{curried}. That is, the definition of \texttt{func} actually looks something like this under the hood:
\begin{minted}{javascript}
function f(int x) {
  function g(int y) {
    return x + y;
  }
  return g;
}
\end{minted}
Thus, in defining \texttt{plus\_4} as \texttt{f 4}, \texttt{plus\_4} is actually like the function \texttt{g}, which has captured the value of \texttt{4} from an outer scope, and which on input \texttt{y} returns \texttt{4 + y}.

This is also the reason why Wye's function types include an arrow between arguments. The function \texttt{f} has type \texttt{int -> int -> int}, the function \texttt{f 4} has type \texttt{int -> int}, and the value obtained from computing \texttt{plus\_4 5} has type \texttt{int}.

\subsubsection{List Construction}\label{expr:cons}
Just like Lisp, OCaml, Haskell, and many other functional languages, lists are an important part of Wye. As such, Wye provides list construction via the ``cons" operator \texttt{::}. Wye also supports pattern matching of lists using cons notation, which is talked about in \ref{expr:pat}.

The cons operator operates as follows: if $x$ is a value of type $t$ and $l$ is a list of type $\texttt{[}t\texttt{]}$, with value $\texttt{[}a_1, a_2, ..., a_n\texttt{]}$ where $n\geq 0$, then \texttt{x :: l} denotes the list $\texttt{[}x, a_1, ..., a_n\texttt{]}$.

The list construction expression falls under the $Expr\: BuiltinOp\: Expr$ grammar substitution rule for $Expr$.

\subsubsection{Using variants of a user-defined type}
If $t$ is a custom type declared via a $TypeDeclaration$ statement, with variants $t_1, ..., t_n$, then one may access the variant $t_i$ as $t_i$. In version \version{} of Wye, for simplicity of the parser, variants with the same name across different user-defined types is not allowed. Thus, the following Wye code compiles:
\begin{lstlisting}{wye}
# synonyms of many
type SynMany = Numerous | Several | Plenty;
# synonyms of abundant
type SynAbundant = Copious | Profuse;
let x = Plenty;
let x = Copious;
\end{lstlisting}
but this does not:
\begin{lstlisting}{wye}
# synonyms of many
type SynMany = Numerous | Several | Plenty;
# synonyms of abundant. ERROR - conflicting variants
type SynAbundant = Plenty | Copious | Profuse;
\end{lstlisting}

If the type variant has a field, then one should use \texttt{with} syntax to define the value of the field. For example:
\begin{lstlisting}{wye}
type Option 'a = None | Some with 'a;
let x: Option int = Some with 4;
\end{lstlisting}

\subsubsection{Match constructs}
The \texttt{match} construct allows control flow of the program to be determined dynamically at runtime, based on whether or not a particular expression matches a pattern. The technical syntax of the \texttt{match} construct is as follows, with match branches separated by a semicolon (\texttt{;}):
\begin{align*}
MatchExpression \substo& \texttt{match}\: Expr \: \texttt{\{} \: (Pat \: \texttt{=>}\: Expr\: \texttt{;})*\: Pat\texttt{ => } Expr \: (\texttt{;}?) \: \texttt{\}}
\end{align*}
or equivalently:
\begin{align*}
MatchExpression \substo& \texttt{match}\: Expr \: \texttt{\{} \: Pat_1 \: \texttt{=>}\: Expr_1\: \texttt{;} \:  ... \: Pat_n \: \texttt{=>}\: Expr_n\: (\texttt{;}?) \: \texttt{\}}
\end{align*}
where $n \geq 1$. 

The operation of the \texttt{match} construct is as follows: the $Expr$ following \texttt{match} is first evaluated to a value $v$. It will then check at runtime whether $v$ against each of $Pat_1$ to $Pat_n$ in order. Let $i$ be the smallest number from $1$ to $n$ such that $v$ matches $Pat_i$ (what it means to ``match" a pattern will be discussed later). This branch will be taken, and only $Expr_i$ will be evaluated. If $v$ matches \textit{none} of the patterns $Pat_1, ..., Pat_n$, Wye will throw a runtime error. 

Each of $Expr_1, ..., Expr_n$ must evaluate to a value of the same type under all possible executions. Thus, the \texttt{match} expression will evaluate to something of exactly one type, under all possible executions.

\subsubsection{Patterns in a Match construct}\label{expr:pat}
The patterns that one can match against in a \texttt{match} are described by the following rules:
\begin{align*}
Pat \substo& Expr \sepbar \uscore\\
& \sepbar Id\:\texttt{::}\: Id\\
& \sepbar TypeId \: (\texttt{with}\: Id)?\\
& \sepbar \texttt{[} \: ( Pat\:\texttt{,})*\: Pat \: \texttt{]} \sepbar  \texttt{[]}\\
& \sepbar \texttt{(} \: ( Pat\:\texttt{,})+\: Pat\: \texttt{)}
\end{align*}
Throughout the subsequent discussion, let $v$ denote the value to which the $Expr$ after the \texttt{match} keyword evaluates. The following list describes when a particular pattern is matched:
\begin{itemize}
\item If $Pat \to Expr$, then the expression on the right is evaluated to some $w$, and $v$ matches this expression iff there is exact equality of $v$ and $w$. Note equality in Wye is always \textit{by value}. This implies that if two expressions do not have the same type, they cannot ever be equal.
\item In particular note that $Expr \to Id$ is possible. Let $x$ denote the $Id$ that occurs. If this $x$ is already present in the outer scope of the \texttt{match} construct, then the value of this $x$ is taken and exact equality is checked between the value of $x$ and $v$. If such $x$ does not exist, Wye should catch the undefined symbol at compile-time.
\item If $Pat \to \uscore$ then $v$ always matches the pattern. \uscore{} is a wildcard in Wye.
\item If $Pat \to Id \:\texttt{::}\: Id$, then $v$ matches the pattern iff $v$ is a list of type $\texttt{[}t\texttt{]}$ with at least one element. This pattern type is better explained with the following example:
\begin{lstlisting}{wye}
match e1 {
	x :: s => e2
}
\end{lstlisting}
Suppose the expression \texttt{e1} evaluates to the value $v$. Then $v$ matches \texttt{x :: s} iff:
\begin{enumerate}
\item $v$ is of some list type $\texttt{[}t\texttt{]}$
\item $v$ has at least one element
\end{enumerate}
If $v$ matches the pattern, then the \textit{new variable} \texttt{x} will be set to the first element of $v$ (the ``head" of $v$) and the \textit{new variable} \texttt{s} will be set to the list containing the remaining elements of $v$, in the original order (that is, \texttt{s} will be set to the ``tail" of $v$). \texttt{x} and \texttt{s} will be available for use in the scope of \texttt{e2} ONLY, and will shadow over variables with the same name in the outer scope. $v$ will always fail to match such a ``list-construction" pattern if it is a list of 0 elements. Note that if $v$ is a list of 1 element, \texttt{x} will always be set to that element, and \texttt{s} will be an empty list.
\item If $Pat \to TypeId$ then $v$ must evaluate to a variant of a type defined in a $TypeDeclaration$ statement. For example, the following pattern matching can be done:
\begin{lstlisting}{wye}
type Operation = Add | Sub | Mul | Div;
let to_string op: Operation -> string = match op {
	Add => "add";
	Sub => "subtract";
	Mul => "multiply";
	Div => "divide"
}
let x = Operation.Mul;
let v = to_string x; # v is "multiply"
\end{lstlisting}
\item Similarly, if $Pat \to TypeId\:\texttt{with}\: Id$, then $b$ must evaluate to a variant of a type defined in a $TypeDeclaration$ statement \textit{that has a field}. In this case, the semantics are similar to the list destructuring pattern \texttt{x :: s}. For example:
\begin{lstlisting}{wye}
type Option 'a = None | Some with 'a;
let print_optional opt: Option string -> string = match opt {
	None => print "nothing!";
	# assume that cat concatenates two strings
	Some with x => print (cat "some with" x);
}
\end{lstlisting}
Thus, if $x$ denotes the $Id$ that occurs after the \texttt{with} keyword, then $x$ is a new variable that is visible within the scope of the expression after the \texttt{=>}. This $Id$ will shadow over a variable with the same name from the outer scope.
\item If $Pat \to []$ then $v$ matches the pattern iff it is an empty list (and it type checks).
\item If $Pat \to \texttt{[}(Pat\: \texttt{,})*\: Pat\texttt{]}$, then $v$ must be a list type in order to match the pattern. Let $p$ denote this pattern. Then $v$ matches $p$ iff:
\begin{enumerate}
\item $v$ is a list of the same length as $p$ (note in this case, $|p| \geq 1$)
\item if $v_i$ is the $i^{th}$ element of $v$ and $p_i$ is the $i^{th}$ pattern in $p$, then for each $i$, $v_i$ must match $p_i$
\end{enumerate}
\item If $Pat \to \texttt{(}(Pat\texttt{,})+ Pat\texttt{)}$, then $v$ must be a tuple type in order to match the pattern. Let $p$ denote this pattern.. Then, $v$ matches $p$ iff:
\begin{enumerate}
\item $v$ is a tuple of the same length as $p$ (note in this case, $|p| \geq 1$)
\item if $v_i$ is the $i^{th}$ element of $v$ and $p_i$ is the $i^{th}$ pattern in $p$, then for each $i$, $v_i$ must match $p_i$ (in type as well).
\end{enumerate}
\item If $Pat\to\:\sim Pat$, let $p$ be the LHS $Pat$ and $q$ be the RHS $Pat$. Then $v$ matches $p$ iff $v$ does not match $q$.
\end{itemize}

\subsubsection{Function overloading}
Wye does not support function overloading of user-defined functions. However, certain functions, such as \texttt{+} are defined on multiple types, which the compiler is able to handle. For an interested reader as to how one would handle function overloading well in a functional language, look up Haskell's ``type classes" and ``kinds".

\subsubsection{Builtin Operations}
There are 6 builtin operations in Wye:
\begin{itemize}
\item[\texttt{+}] adds two \texttt{int}s or \texttt{float}s or concatenates two \texttt{string}s or lists. Wye does not support addition of \texttt{int} and \texttt{float}. An explicit cast must occur (more on this later).
\item[\texttt{-}] an expression \texttt{a - b} results in the subtraction of the value \texttt{b} from the value \texttt{a}. Subtraction is supported only on \texttt{int}s and \texttt{float}s.
\item[\texttt{*}] multiplication of \texttt{int}s or \texttt{float}s.
\item[\texttt{/}] an expression \texttt{a / b} results in the division of the value \texttt{a} by the value \texttt{b}. In Wye, division is supported \textit{only for \texttt{float}s}. If \texttt{b} is the value 0, then Wye will throw a division-by-zero error at runtime.
\item[\texttt{//}] an expression \texttt{a // b} results in the floor division of the value \texttt{a} by the value \texttt{b}. In Wye floor division is supported \textit{only when \texttt{a} is a \texttt{float} and \texttt{b} is an \texttt{int}}. If \texttt{b} is the integer 0, then Wye will throw a division-by-zero error at runtime.
\item[\texttt{::}] as discussed in \ref{expr:cons}, \texttt{::} is the list construction operator in Wye for constructing a list via specifying its head and tail.
\end{itemize}

Wye's builtin binary operations can be written both in postfix notation (for example, division can be written as \texttt{(/ a b)}), or in infix notation (\texttt{a / b}).

\subsection{Types}

\subsubsection{Basic types}

Wye has essentially 3 builtin primitive types, with support for constructing list and tuple data structures. The three primitive types are:

\texttt{int:} a 64-bit signed integer.

\texttt{float:} a 64-bit floating point number.

\texttt{string:} essentially a list of 4-byte unicode characters.

The specification for the types of lists and tuples has already been demonstrated earlier.

\subsubsection{Polymorphic types}

Just like OCaml and Haskell, Wye's type system is based on the Hindley-Milner type system and thus supports polymorphic types. A polymorphic type is essentially a type of the form $\forall \alpha \sigma$ where $\sigma$ is a type signature in which $\alpha$ is a free variable. Such type signatures have been referred to earlier, for example in the \texttt{Option} type:
\begin{lstlisting}{wye}
type Option 'a = None | Some with 'a;
\end{lstlisting}
Or, in the identity function:
\begin{lstlisting}{wye}
let id x: 'a -> 'a = x;
\end{lstlisting}
In Wye, the \texttt{'} token specifies that the $Id$ immediately following it is a \textit{type variable} which is implicitly quantified over in a type expression (an expression that evaluates to a type). In this way, the function \texttt{id} can take in \texttt{any value} of \texttt{any type}! The function's argument is polymorphic.

Whenever the \texttt{id} function is called, it actually implicitly takes in a \textit{type argument} -- namely, the type of its actual argument! Due to Wye's type system, this type is actually known at compile-time, and thus type checking can be adequately performed via substitution of the quantified type variable \texttt{a} with whatever type the function is called with. For example, the following code type-checks, with the type variable \texttt{a} being substituted with \texttt{string} and the type variable \texttt{b} being substituted with \texttt{int}:
\begin{lstlisting}{wye}
type OptionalTuple 'a 'b = None | Some with ('a, 'b);
let f x: 'a -> y: 'b -> OptionalTuple 'a, 'b = Some with (x, y);
# j is of variant Some with (string, int)
let j = f "hello" 4;
\end{lstlisting}

\subsubsection{Type inference}

Wye is a statically typed language, and due to its Hindley-Milner type system, it is able to infer the types of expressions (and thus variables) at compile-time. The exact rules for the type system will be talked about in greater detail in the Type Checking section of this document. However, it is important to note that Wye expressions, when not annotated with a type, are typed to the \textit{most general possible type}. For example, in the following code:
\begin{lstlisting}{wye}
let cons x lst = x :: lst;
\end{lstlisting}
the function \texttt{cons} type checks to the functional type \texttt{'a -> ['a] -> 'a}.

For more information, the interested reader should check out the \href{{https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system}}{the Hindley-Milner type system}.

\section{Type Checking}

In order to verify at compile-time that a program accomplishes the author's intention, it is helpful to type-check the program at compile-time. Type checking is the process of verifying that all operations in the program are performed on values of appropriate types. Type checking can be performed at compile-time only if the types of every Wye expression are known at compile-time. Thus, if the Wye compiler cannot figure out the type of a Wye expression, the compiler will refuse to compile the input program. Type checking is achieved via deductive reasoning on the input program based on certain deductive rules. In version \version{} of Wye's compiler, type checking is implemented via a depth-first traversal of the Abstract Syntax Tree of an input Wye program.

\subsection{Notation}

The rules by which Wye performs type checking are written in the following form:
\begin{align*}
\frac{hypothesis_1, ..., hypothesis_n}{conclusion}
\end{align*}

In order to perform typing, a context is necessary. For example, if a function \texttt{f} is applied in an expression, then \texttt{f} must be defined somewhere. The set of variables, functions, and types available in scope for use in an expression is referred to as the \textit{context} and notated as $\Gamma$.

The symbol $\vdash$ means ``entails" or ``proves." We say $\Gamma\vdash e: \tau$ if the context $\Gamma$ and the deductive rules of Wye's type system prove that the expression $e$ has type $\tau$. If interested in the origins of this symbol, the reader should look into soundness and completeness in mathematical logic.

A comma between hypotheses indicates a logical and. That is, $hypothesis_1, hypothesis_2$ is logically equivalent to $hypothesis_1 \wedge hypothesis_2$. Moreover, $\Gamma$ can be considered a hypothesis itself, an assertion that all declared variables and functions have their specific types, along with assertions about the available types. Thus, the notation $\Gamma, hypothesis \vdash e: \tau$ may be used to express that $\Gamma \wedge hypothesis$ proves that $e: \tau$.

In general, $\tau$ will be used to indicate a monomorphic type (i.e., a ``concrete" type like \texttt{int}), and $\sigma$ will be used to indicate a polymorphic type. Any type with a type variable, i.e., with an implicit quantifier over a type parameter, is a polymorphic type.

Also important to consider are the free type variables in a type expression. For example in the identity function:
\begin{lstlisting}{wye}
let f x: 'a -> 'a = x;
\end{lstlisting}
within the expression on the right hand side of the \texttt{=} (namely, \texttt{x}), the type of the parameter $x$ is free. It is equal to some \texttt{a} which is only concretized when \texttt{f} is applied to some parameter.

On the other hand, there are no free variables in \texttt{f}'s type. \texttt{f} has the type $\forall a\: a\to a$ -- all the type variables in this function definition have been fully quantified over.

The set of free variables in an expression or set of expressions $S$ is notated as $\free(S)$. free is defined as follows:
\begin{enumerate}
\item if $\alpha$ is a type variable, $\free(\alpha) = \alpha$.
\item if $C$ is a type function (a variant of a user-defined type with a field), then $\free(C\: \tau) = free(\tau)$
\item if $\Gamma$ is a context, then $\free(\Gamma) = \bigcup_{x : \sigma\in\Gamma }free(\sigma)$ where the union is taken over all distinct polymorphic types of variables or functions in $\Gamma$.
\item for polymorphic types, $\free(\forall \alpha \: \sigma) = \free(\sigma) - \{\alpha\}$
\item for contexts, $\free(\Gamma\vdash e: \sigma) = \free(\sigma) - \free(\Gamma)$
\end{enumerate}

\subsection{Type order}

Before we give the rules for type inference, it is important to define an ordering on types. This allows Wye to infer the most general type possible for an expression (the ``least" potential type in this type ordering), which creates a highly flexible yet still strict type system.

\subsection{Typing expressions}




\pagebreak
\section{Acknowledgements}
The syntax and semantics of Wye are based on Rust, Haskell, and OCaml. I thank the developers of these languages for making it much easier for me to learn about and write a compiler. I thank Jens Palsberg of UCLA for teaching me the fundamentals of compiler implementation.

% --- Bibliography ---
\pagebreak
% change bibliography style if you want
\bibliographystyle{ieeetr}
\bibliography{references}

% --- Appendices ---
% \pagebreak
% \begin{appendices}
% \section{Thoughtfully named Appendix}
% \end{appendices}

\end{document}